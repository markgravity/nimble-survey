//
//  NimbleSurveyMocks.generated.swift
//  NimbleSurvey
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import NimbleSurvey
import Alamofire
import AlamofireImage
import Burritos
import Foundation
import L10n_swift
import ObjectMapper
import Promises
import RxSwift
import Swift
import SwiftyBase
import SwiftyComponent
import SwiftyJSON
import SwiftyPopup
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ApiService

public final class ApiServiceMock: NimbleSurvey.ApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?)

  public func `request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse>", arguments: [Mockingbird.ArgumentMatcher(`method`), Mockingbird.ArgumentMatcher(`baseUrl`), Mockingbird.ArgumentMatcher(`endPoint`), Mockingbird.ArgumentMatcher(`token`), Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse> {
      return concreteImplementation(`method`, `baseUrl`, `endPoint`, `token`, `params`)
    } else {
      return (implementation as! () -> Promise<ApiResponse>)()
    }
  }

  public func `request`(`method`: @escaping @autoclosure () -> HttpMethod, `baseUrl`: @escaping @autoclosure () -> String?, `endPoint`: @escaping @autoclosure () -> String, `token`: @escaping @autoclosure () -> String?, `params`: @escaping @autoclosure () -> HttpParametable?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse>, Promise<ApiResponse>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`method`), Mockingbird.resolve(`baseUrl`), Mockingbird.resolve(`endPoint`), Mockingbird.resolve(`token`), Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse>, Promise<ApiResponse>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.ApiService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.ApiService.Protocol) -> ApiServiceMock {
  return ApiServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AuthForgotPasswordVM

public final class AuthForgotPasswordVMMock: NimbleSurvey.AuthForgotPasswordVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AuthForgotPasswordVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked isValid

  public var `isValid`: Observable<Bool> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isValid.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Observable<Bool>)()
    }
  }

  public func getIsValid() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<Bool>, Observable<Bool>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isValid.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<Bool>, Observable<Bool>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked state

  public var `state`: ValueObservable<NimbleSurvey.AuthForgotPasswordState> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<NimbleSurvey.AuthForgotPasswordState>)()
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<NimbleSurvey.AuthForgotPasswordState>, ValueObservable<NimbleSurvey.AuthForgotPasswordState>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<NimbleSurvey.AuthForgotPasswordState>, ValueObservable<NimbleSurvey.AuthForgotPasswordState>>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `reset`()

  public func `reset`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`reset`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `reset`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`reset`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setEmail`(_ `text`: String?)

  public func `setEmail`(_ `text`: String?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setEmail`(_ `text`: String?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`text`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String?) -> Void {
      concreteImplementation(`text`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setEmail`(_ `text`: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`text`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setEmail`(_ `text`: String?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.AuthForgotPasswordVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.AuthForgotPasswordVM.Protocol) -> AuthForgotPasswordVMMock {
  return AuthForgotPasswordVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AuthService

public final class AuthServiceMock: NimbleSurvey.AuthService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AuthServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `forgotPassword`(`params`: AuthForgotPasswordParams)

  public func `forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthForgotPasswordParams) -> Promise<Void> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `forgotPassword`(`params`: @escaping @autoclosure () -> AuthForgotPasswordParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthForgotPasswordParams) -> Promise<Void>, Promise<Void>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthForgotPasswordParams) -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `login`(`params`: AuthLoginParams)

  public func `login`(`params`: AuthLoginParams) -> Promise<UserTokenInfo> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`(`params`: AuthLoginParams) -> Promise<UserTokenInfo>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthLoginParams) -> Promise<UserTokenInfo> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<UserTokenInfo>)()
    }
  }

  public func `login`(`params`: @escaping @autoclosure () -> AuthLoginParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLoginParams) -> Promise<UserTokenInfo>, Promise<UserTokenInfo>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`(`params`: AuthLoginParams) -> Promise<UserTokenInfo>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLoginParams) -> Promise<UserTokenInfo>, Promise<UserTokenInfo>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `logout`(`params`: AuthLogoutParams)

  public func `logout`(`params`: AuthLogoutParams) -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`logout`(`params`: AuthLogoutParams) -> Promise<Void>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthLogoutParams) -> Promise<Void> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `logout`(`params`: @escaping @autoclosure () -> AuthLogoutParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLogoutParams) -> Promise<Void>, Promise<Void>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`logout`(`params`: AuthLogoutParams) -> Promise<Void>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLogoutParams) -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `refreshToken`(`params`: AuthRefreshTokenParams)

  public func `refreshToken`(`params`: AuthRefreshTokenParams) -> Promise<UserTokenInfo> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refreshToken`(`params`: AuthRefreshTokenParams) -> Promise<UserTokenInfo>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthRefreshTokenParams) -> Promise<UserTokenInfo> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<UserTokenInfo>)()
    }
  }

  public func `refreshToken`(`params`: @escaping @autoclosure () -> AuthRefreshTokenParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthRefreshTokenParams) -> Promise<UserTokenInfo>, Promise<UserTokenInfo>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refreshToken`(`params`: AuthRefreshTokenParams) -> Promise<UserTokenInfo>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthRefreshTokenParams) -> Promise<UserTokenInfo>, Promise<UserTokenInfo>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.AuthService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.AuthService.Protocol) -> AuthServiceMock {
  return AuthServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AuthVM

public final class AuthVMMock: NimbleSurvey.AuthVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AuthVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked isAuthenticated

  public var `isAuthenticated`: ValueObservable<Bool> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isAuthenticated.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<Bool>)()
    }
  }

  public func getIsAuthenticated() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<Bool>, ValueObservable<Bool>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isAuthenticated.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<Bool>, ValueObservable<Bool>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked user

  public var `user`: ValueObservable<UserInfo?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "user.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<UserInfo?>)()
    }
  }

  public func getUser() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<UserInfo?>, ValueObservable<UserInfo?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "user.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<UserInfo?>, ValueObservable<UserInfo?>>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `forgotPassword`(`params`: AuthForgotPasswordParams)

  public func `forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthForgotPasswordParams) -> Promise<Void> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `forgotPassword`(`params`: @escaping @autoclosure () -> AuthForgotPasswordParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthForgotPasswordParams) -> Promise<Void>, Promise<Void>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`forgotPassword`(`params`: AuthForgotPasswordParams) -> Promise<Void>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthForgotPasswordParams) -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `login`(`params`: AuthLoginParams)

  public func `login`(`params`: AuthLoginParams) -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`(`params`: AuthLoginParams) -> Promise<Void>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AuthLoginParams) -> Promise<Void> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `login`(`params`: @escaping @autoclosure () -> AuthLoginParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLoginParams) -> Promise<Void>, Promise<Void>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`(`params`: AuthLoginParams) -> Promise<Void>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AuthLoginParams) -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `logout`()

  public func `logout`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`logout`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `logout`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`logout`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `refreshToken`()

  public func `refreshToken`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refreshToken`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `refreshToken`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refreshToken`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `retrieve`()

  public func `retrieve`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieve`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `retrieve`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`retrieve`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.AuthVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.AuthVM.Protocol) -> AuthVMMock {
  return AuthVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DateService

public final class DateServiceMock: NimbleSurvey.DateService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DateServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `now`()

  public func `now`() -> Date {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`now`() -> Date", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Date {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Date)()
    }
  }

  public func `now`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Date, Date> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`now`() -> Date", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Date, Date>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.DateService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.DateService.Protocol) -> DateServiceMock {
  return DateServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HomeVM

public final class HomeVMMock: NimbleSurvey.HomeVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HomeVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked currentDateText

  public var `currentDateText`: Observable<String> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentDateText.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Observable<String>)()
    }
  }

  public func getCurrentDateText() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<String>, Observable<String>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentDateText.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<String>, Observable<String>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked focusIndex

  public var `focusIndex`: ValueObservable<Int> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "focusIndex.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<Int>)()
    }
  }

  public func getFocusIndex() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<Int>, ValueObservable<Int>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "focusIndex.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<Int>, ValueObservable<Int>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked focusItem

  public var `focusItem`: Observable<SurveyInfo?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "focusItem.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Observable<SurveyInfo?>)()
    }
  }

  public func getFocusItem() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<SurveyInfo?>, Observable<SurveyInfo?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "focusItem.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<SurveyInfo?>, Observable<SurveyInfo?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked items

  public var `items`: ValueObservable<[SurveyInfo]> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "items.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<[SurveyInfo]>)()
    }
  }

  public func getItems() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<[SurveyInfo]>, ValueObservable<[SurveyInfo]>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "items.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<[SurveyInfo]>, ValueObservable<[SurveyInfo]>>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `refresh`(`force`: Bool)

  public func `refresh`(`force`: Bool) -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refresh`(`force`: Bool) -> Promise<Void>", arguments: [Mockingbird.ArgumentMatcher(`force`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Promise<Void> {
      return concreteImplementation(`force`)
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `refresh`(`force`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Promise<Void>, Promise<Void>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`force`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`refresh`(`force`: Bool) -> Promise<Void>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setFocusIndex`(_ `index`: Int)

  public func `setFocusIndex`(_ `index`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setFocusIndex`(_ `index`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`index`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`index`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setFocusIndex`(_ `index`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`index`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setFocusIndex`(_ `index`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.HomeVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.HomeVM.Protocol) -> HomeVMMock {
  return HomeVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HttpService

public final class HttpServiceMock: NimbleSurvey.HttpService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HttpServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?)

  public func `request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data>", arguments: [Mockingbird.ArgumentMatcher(`method`), Mockingbird.ArgumentMatcher(`baseUrl`), Mockingbird.ArgumentMatcher(`endPoint`), Mockingbird.ArgumentMatcher(`params`), Mockingbird.ArgumentMatcher(`headers`), Mockingbird.ArgumentMatcher(`interceptor`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data> {
      return concreteImplementation(`method`, `baseUrl`, `endPoint`, `params`, `headers`, `interceptor`)
    } else {
      return (implementation as! () -> Promise<Data>)()
    }
  }

  public func `request`(`method`: @escaping @autoclosure () -> HttpMethod, `baseUrl`: @escaping @autoclosure () -> String, `endPoint`: @escaping @autoclosure () -> String, `params`: @escaping @autoclosure () -> HttpParametable?, `headers`: @escaping @autoclosure () -> HttpHeaders?, `interceptor`: @escaping @autoclosure () -> RequestInterceptor?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data>, Promise<Data>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`method`), Mockingbird.resolve(`baseUrl`), Mockingbird.resolve(`endPoint`), Mockingbird.resolve(`params`), Mockingbird.resolve(`headers`), Mockingbird.resolve(`interceptor`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data>, Promise<Data>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.HttpService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.HttpService.Protocol) -> HttpServiceMock {
  return HttpServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked LandingVM

public final class LandingVMMock: NimbleSurvey.LandingVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LandingVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetch`()

  public func `fetch`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `fetch`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fetch`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.LandingVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.LandingVM.Protocol) -> LandingVMMock {
  return LandingVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked LoginVM

public final class LoginVMMock: NimbleSurvey.LoginVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LoginVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked isValid

  public var `isValid`: Observable<Bool> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isValid.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Observable<Bool>)()
    }
  }

  public func getIsValid() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<Bool>, Observable<Bool>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "isValid.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Observable<Bool>, Observable<Bool>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked state

  public var `state`: ValueObservable<NimbleSurvey.LoginState> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> ValueObservable<NimbleSurvey.LoginState>)()
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<NimbleSurvey.LoginState>, ValueObservable<NimbleSurvey.LoginState>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> ValueObservable<NimbleSurvey.LoginState>, ValueObservable<NimbleSurvey.LoginState>>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `login`()

  public func `login`() -> Promise<Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`() -> Promise<Void>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<Void> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<Void>)()
    }
  }

  public func `login`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`() -> Promise<Void>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<Void>, Promise<Void>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setEmail`(_ `text`: String?)

  public func `setEmail`(_ `text`: String?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setEmail`(_ `text`: String?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`text`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String?) -> Void {
      concreteImplementation(`text`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setEmail`(_ `text`: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`text`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setEmail`(_ `text`: String?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setPassword`(_ `text`: String?)

  public func `setPassword`(_ `text`: String?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPassword`(_ `text`: String?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`text`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String?) -> Void {
      concreteImplementation(`text`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setPassword`(_ `text`: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`text`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPassword`(_ `text`: String?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.LoginVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.LoginVM.Protocol) -> LoginVMMock {
  return LoginVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SurveyService

public final class SurveyServiceMock: NimbleSurvey.SurveyService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SurveyServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `list`(`params`: SurveyListParams)

  public func `list`(`params`: SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`list`(`params`: SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>>", arguments: [Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>> {
      return concreteImplementation(`params`)
    } else {
      return (implementation as! () -> Promise<NimbleSurvey.ListResponse<SurveyInfo>>)()
    }
  }

  public func `list`(`params`: @escaping @autoclosure () -> SurveyListParams) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>>, Promise<NimbleSurvey.ListResponse<SurveyInfo>>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`list`(`params`: SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SurveyListParams) -> Promise<NimbleSurvey.ListResponse<SurveyInfo>>, Promise<NimbleSurvey.ListResponse<SurveyInfo>>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.SurveyService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.SurveyService.Protocol) -> SurveyServiceMock {
  return SurveyServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TimerService

public final class TimerServiceMock: NimbleSurvey.TimerService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TimerServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `scheduledTimer`(`withTimeInterval` `interval`: TimeInterval, `repeats`: Bool, `block`: @escaping (Timer) -> Void)

  public func `scheduledTimer`(`withTimeInterval` `interval`: TimeInterval, `repeats`: Bool, `block`: @escaping (Timer) -> Void) -> Timer {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scheduledTimer`(`withTimeInterval` `interval`: TimeInterval, `repeats`: Bool, `block`: @escaping (Timer) -> Void) -> Timer", arguments: [Mockingbird.ArgumentMatcher(`interval`), Mockingbird.ArgumentMatcher(`repeats`), Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (TimeInterval, Bool, @escaping (Timer) -> Void) -> Timer {
      return concreteImplementation(`interval`, `repeats`, `block`)
    } else {
      return (implementation as! () -> Timer)()
    }
  }

  public func `scheduledTimer`(`withTimeInterval` `interval`: @escaping @autoclosure () -> TimeInterval, `repeats`: @escaping @autoclosure () -> Bool, `block`: @escaping @autoclosure () -> (Timer) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TimeInterval, Bool, @escaping (Timer) -> Void) -> Timer, Timer> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`interval`), Mockingbird.resolve(`repeats`), Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scheduledTimer`(`withTimeInterval` `interval`: TimeInterval, `repeats`: Bool, `block`: @escaping (Timer) -> Void) -> Timer", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TimeInterval, Bool, @escaping (Timer) -> Void) -> Timer, Timer>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.TimerService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.TimerService.Protocol) -> TimerServiceMock {
  return TimerServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UserService

public final class UserServiceMock: NimbleSurvey.UserService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UserServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `me`()

  public func `me`() -> Promise<UserInfo> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`me`() -> Promise<UserInfo>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Promise<UserInfo> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Promise<UserInfo>)()
    }
  }

  public func `me`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<UserInfo>, Promise<UserInfo>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`me`() -> Promise<UserInfo>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Promise<UserInfo>, Promise<UserInfo>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.UserService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.UserService.Protocol) -> UserServiceMock {
  return UserServiceMock(sourceLocation: SourceLocation(file, line))
}
