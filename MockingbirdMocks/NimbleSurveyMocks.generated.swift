//
//  NimbleSurveyMocks.generated.swift
//  NimbleSurvey
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import NimbleSurvey
import Alamofire
import Foundation
import L10n_swift
import ObjectMapper
import Promises
import RxSwift
import Swift
import SwiftyBase
import SwiftyJSON
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ApiService

public final class ApiServiceMock: NimbleSurvey.ApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?)

  public func `request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse>", arguments: [Mockingbird.ArgumentMatcher(`method`), Mockingbird.ArgumentMatcher(`baseUrl`), Mockingbird.ArgumentMatcher(`endPoint`), Mockingbird.ArgumentMatcher(`token`), Mockingbird.ArgumentMatcher(`params`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse> {
      return concreteImplementation(`method`, `baseUrl`, `endPoint`, `token`, `params`)
    } else {
      return (implementation as! () -> Promise<ApiResponse>)()
    }
  }

  public func `request`(`method`: @escaping @autoclosure () -> HttpMethod, `baseUrl`: @escaping @autoclosure () -> String?, `endPoint`: @escaping @autoclosure () -> String, `token`: @escaping @autoclosure () -> String?, `params`: @escaping @autoclosure () -> HttpParametable?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse>, Promise<ApiResponse>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`method`), Mockingbird.resolve(`baseUrl`), Mockingbird.resolve(`endPoint`), Mockingbird.resolve(`token`), Mockingbird.resolve(`params`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String?, `endPoint`: String, `token`: String?, `params`: HttpParametable?) -> Promise<ApiResponse>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String?, String, String?, HttpParametable?) -> Promise<ApiResponse>, Promise<ApiResponse>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.ApiService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.ApiService.Protocol) -> ApiServiceMock {
  return ApiServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AuthVM

public final class AuthVMMock: NimbleSurvey.AuthVM, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AuthVMMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `login`()

  public func `login`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `login`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`login`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.AuthVM` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.AuthVM.Protocol) -> AuthVMMock {
  return AuthVMMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HttpService

public final class HttpServiceMock: NimbleSurvey.HttpService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "NimbleSurvey"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HttpServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?)

  public func `request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data>", arguments: [Mockingbird.ArgumentMatcher(`method`), Mockingbird.ArgumentMatcher(`baseUrl`), Mockingbird.ArgumentMatcher(`endPoint`), Mockingbird.ArgumentMatcher(`params`), Mockingbird.ArgumentMatcher(`headers`), Mockingbird.ArgumentMatcher(`interceptor`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data> {
      return concreteImplementation(`method`, `baseUrl`, `endPoint`, `params`, `headers`, `interceptor`)
    } else {
      return (implementation as! () -> Promise<Data>)()
    }
  }

  public func `request`(`method`: @escaping @autoclosure () -> HttpMethod, `baseUrl`: @escaping @autoclosure () -> String, `endPoint`: @escaping @autoclosure () -> String, `params`: @escaping @autoclosure () -> HttpParametable?, `headers`: @escaping @autoclosure () -> HttpHeaders?, `interceptor`: @escaping @autoclosure () -> RequestInterceptor?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data>, Promise<Data>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`method`), Mockingbird.resolve(`baseUrl`), Mockingbird.resolve(`endPoint`), Mockingbird.resolve(`params`), Mockingbird.resolve(`headers`), Mockingbird.resolve(`interceptor`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`method`: HttpMethod, `baseUrl`: String, `endPoint`: String, `params`: HttpParametable?, `headers`: HttpHeaders?, `interceptor`: RequestInterceptor?) -> Promise<Data>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HttpMethod, String, String, HttpParametable?, HttpHeaders?, RequestInterceptor?) -> Promise<Data>, Promise<Data>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `NimbleSurvey.HttpService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: NimbleSurvey.HttpService.Protocol) -> HttpServiceMock {
  return HttpServiceMock(sourceLocation: SourceLocation(file, line))
}
